<!--
  ~ Copyright (c) 2012, The Broad Institute
  ~
  ~ Permission is hereby granted, free of charge, to any person
  ~ obtaining a copy of this software and associated documentation
  ~ files (the "Software"), to deal in the Software without
  ~ restriction, including without limitation the rights to use,
  ~ copy, modify, merge, publish, distribute, sublicense, and/or sell
  ~ copies of the Software, and to permit persons to whom the
  ~ Software is furnished to do so, subject to the following
  ~ conditions:
  ~
  ~ The above copyright notice and this permission notice shall be
  ~ included in all copies or substantial portions of the Software.
  ~ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  ~ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  ~ OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  ~ NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  ~ HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  ~ WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  ~ FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  ~ OTHER DEALINGS IN THE SOFTWARE.
  -->

<!-- To get a list of the major build targets, run "ant -p" -->
<project name="Sting" default="dist" basedir="."
         xmlns:artifact="antlib:org.apache.maven.artifact.ant"
         xmlns:ivy="antlib:org.apache.ivy.ant">
    <description>Compile and distribute the Sting toolkit</description>

    <!-- ******************************************************************************** -->
    <!-- Properties                                                                       -->
    <!-- ******************************************************************************** -->

    <!-- The system classpath should take precedence over classpaths specified in this file -->
    <property name="build.sysclasspath" value="first" />

    <!-- Use this prefix to access environment variables -->
    <property environment="env"/>

    <!-- Build defaults: -->
    <property name="default.build.target" value="all" />       <!-- can be "all", "public" (public only), or "protected" (public + protected) -->
    <property name="compile.scala.by.default" value="true" />  <!-- compile Scala by default? "true" or "false" -->
    <property name="use.contracts.by.default" value="false" /> <!-- should contracts be built by default? "true" or "false -->

    <!-- Top-level directories -->
    <property name="build.dir" value="build" />
    <property name="dist.dir" value="dist" />
    <property name="lib.dir" value="lib" />
    <property name="public.dir" value="public" />
    <property name="private.dir" value="private" />
    <property name="protected.dir" value="protected" />
    <property name="external.dir" value="external" />

    <!-- Source directories -->
    <property name="java.public.source.dir" value="${public.dir}/java/src" />
    <property name="java.private.source.dir" value="${private.dir}/java/src" />
    <property name="java.protected.source.dir" value="${protected.dir}/java/src" />
    <property name="scala.public.source.dir" value="${public.dir}/scala/src" />
    <property name="scala.private.source.dir" value="${private.dir}/scala/src" />
    <property name="scala.protected.source.dir" value="${protected.dir}/scala/src" />
    <property name="queue-extensions.source.dir" value="${build.dir}/queue-extensions/src" />
    <property name="R.public.scripts.dir" value="${public.dir}/R/scripts" />
    <property name="R.private.scripts.dir" value="${private.dir}/R/scripts" />
    <property name="R.protected.scripts.dir" value="${protected.dir}/R/scripts" />
    <property name="R.public.src.dir" value="${public.dir}/R/src" />

    <!-- Build directories -->
    <property name="java.classes" value="${build.dir}/java/classes" />
    <property name="scala.classes" value="${build.dir}/scala/classes" />
    <property name="R.library.dir" value="${public.dir}/R" />  <!-- TODO: Installing libraries back into the source directory: intentionally avoids ant clean?? -->
    <property name="R.tar.dir" value="${build.dir}/R/src" />
    <property name="R.package.path" value="org/broadinstitute/sting/utils/R" />
    <property name="R.script.staging.dir" value="${build.dir}/R/stage" />

    <!-- Packaging system properties -->
    <property name="package.xml.dir" value="${public.dir}/packages" />
    <property name="package.output.dir" value="${dist.dir}/packages" />
    <property name="staging.dir" value="staging" />
    <property name="default.executable" value="none" />

    <!-- GATKDocs/Javadoc/Scaladoc directories -->
    <property name="gatkdocs.dir" value="gatkdocs" />
    <property name="javadoc.dir" value="javadoc" />
    <property name="scaladoc.dir" value="scaladoc" />

    <!-- Resource file used for help text and version information -->
    <property name="resource.file" value="StingText.properties" />
    <property name="resource.path" value="${java.classes}/StingText.properties" />

    <!-- Directory containing cryptographic keys used by the GATK -->
    <property name="key.dir" value="${public.dir}/keys" />

    <!-- Contracts for Java -->
    <!-- Disabled by default -->
    <!-- To enable, run with -Duse.contracts=true -->
    <property name="java.contracts.dir" value="${build.dir}/java/contracts" />
    <property name="contracts.version" value="1.0-r139" />
    <property name="cofoja.jar" value="${lib.dir}/cofoja-${contracts.version}.jar"/>
    <property name="contract.dump.dir" value="dump" />

    <!-- do we want to halt on failure of a unit test? default to yes (Bamboo uses 'no') -->
    <property name="halt" value="yes" />

    <!-- should our unit test output go to a file or the screen? false means it goes to the screen (default) true to file -->
    <property name="usefile" value="false" />

    <!-- To run tests with debugging, use -Dtest.debug=true -Dtest.debug.port=XXXX on the command line -->
    <property name="test.debug.port" value="5005" />  <!-- override on the command line if desired -->
    <property name="test.default.maxmemory" value="4g"/>

    <!-- clover parameters -->
    <property name="clover.jar" location="private/resources/clover/lib/clover.jar"/>
    <property name="clover.instrument.level" value="method"/>
    <taskdef resource="cloverlib.xml" classpath="${clover.jar}"/>

    <!-- ******************************************************************************** -->
    <!-- Filesets and paths                                                               -->
    <!-- ******************************************************************************** -->

    <!-- All the complexity of selecting among public/private/protected should be up here, not down in the targets -->

    <patternset id="java.source.directories.pattern">
        <include name="${java.public.source.dir}" />
        <include name="${java.private.source.dir}" if="include.private" />
        <include name="${java.protected.source.dir}" if="include.protected" />
    </patternset>

    <patternset id="java.source.files.pattern">
        <include name="${java.public.source.dir}/**/*.java" />
        <include name="${java.private.source.dir}/**/*.java" if="include.private" />
        <include name="${java.protected.source.dir}/**/*.java" if="include.protected" />
    </patternset>

    <patternset id="scala.source.directories.pattern">
        <include name="${scala.public.source.dir}" />
        <include name="${scala.private.source.dir}" if="include.private" />
        <include name="${scala.protected.source.dir}" if="include.protected" />
    </patternset>

    <patternset id="scala.source.files.pattern">
        <include name="${scala.public.source.dir}/**/*.scala" />
        <include name="${scala.private.source.dir}/**/*.scala" if="include.private" />
        <include name="${scala.protected.source.dir}/**/*.scala" if="include.protected" />
    </patternset>

    <patternset id="R.script.source.directories.pattern">
        <include name="${R.public.scripts.dir}" />
        <include name="${R.private.scripts.dir}" if="include.private" />
        <include name="${R.protected.scripts.dir}" if="include.protected" />
    </patternset>

    <patternset id="R.script.source.files.pattern">
        <include name="${R.public.scripts.dir}/**/*.R" />
        <include name="${R.private.scripts.dir}/**/*.R" if="include.private" />
        <include name="${R.protected.scripts.dir}/**.*.R" if="include.protected" />
    </patternset>

    <path id="java.source.path">
        <dirset dir="${basedir}">
            <patternset refid="java.source.directories.pattern" />
        </dirset>
    </path>

    <path id="scala.source.path">
        <dirset dir="${basedir}">
            <patternset refid="scala.source.directories.pattern" />
        </dirset>
    </path>

    <path id="R.script.source.path">
        <dirset dir="${basedir}">
            <patternset refid="R.script.source.directories.pattern" />
        </dirset>
    </path>

    <fileset id="java.source.files" dir="${basedir}">
        <patternset refid="java.source.files.pattern" />
    </fileset>

    <fileset id="scala.source.files" dir="${basedir}">
        <patternset refid="scala.source.files.pattern" />
    </fileset>

    <fileset id="R.script.source.files" dir="${basedir}">
        <patternset refid="R.script.source.files.pattern" />
    </fileset>

    <fileset id="java.class.files" dir="${java.classes}" erroronmissingdir="false">
        <include name="**/*.class"/>
    </fileset>

    <patternset id="dependency.mask" includes="*.jar" />

    <path id="external.dependencies">
        <fileset dir="${lib.dir}" erroronmissingdir="false">
            <patternset refid="dependency.mask" />
        </fileset>
    </path>

    <path id="scala.dependencies">
        <path refid="external.dependencies" />
        <pathelement location="${java.classes}" />
        <!-- Need the resources as we will be running a command line program which needs the help text. -->
        <pathelement location="${resource.path}" />
        <!-- Add any previously compiled scala classes to the path. -->
        <pathelement location="${scala.classes}" />
    </path>

    <path id="build.results">
        <!-- Ensure that GenomeAnalysisTK.jar comes first in the path, as it contains overrides for certain classes in our dependencies -->
        <pathelement location="${dist.dir}/GenomeAnalysisTK.jar" />
        <!-- After GenomeAnalysisTK.jar we include all of the other jars in the dist directory -->
        <fileset dir="${dist.dir}" erroronmissingdir="false">
            <patternset refid="dependency.mask" />
            <exclude name="GenomeAnalysisTK.jar" />
        </fileset>
    </path>

    <fileset id="external.source.files" dir="${external.dir}" erroronmissingdir="false">
        <include name="**/*.java" />
    </fileset>

    <path id="external.build.dir">
        <path path="${java.classes}" />
    </path>

    <path id="external.dist.dir">
        <path path="${dist.dir}" />
    </path>

    <!-- GATK dependencies consist of 3rd party plugins plus compiled GATK classes -->
    <path id="external.gatk.classpath">
        <path path="${java.classes}"/>
        <path refid="external.dependencies" />
    </path>

    <!-- the path for resources that need to go into the GATK jar;
         any additional resources should go into this set. -->
    <path id="gatk.resources">
        <fileset dir="${java.public.source.dir}">
            <include name="**/resources/*" />
            <include name="**/templates/*" />
        </fileset>
        <fileset dir="${java.private.source.dir}" erroronmissingdir="false">
            <include name="**/resources/*" if="include.private" />
            <include name="**/templates/*" if="include.private" />
        </fileset>
        <fileset dir="${java.protected.source.dir}" erroronmissingdir="false">
            <include name="**/resources/*" if="include.protected" />
            <include name="**/templates/*" if="include.protected" />
        </fileset>
    </path>

    <!-- ******************************************************************************** -->
    <!-- Ivy Retrieve                                                                     -->
    <!-- ******************************************************************************** -->

    <target name="init.resolve" unless="init.resolve.done">
        <!-- ivy properties -->
        <property name="ivy.install.version" value="2.2.0"/>
        <property name="ivy.home" value="${user.home}/.ant"/>
        <property name="ivy.jar.dir" value="${ivy.home}/${lib.dir}"/>
        <property name="ivy.jar.file" value="ivy-${ivy.install.version}.jar"/>
        <property name="ivy.settings.dir" value="settings"/>
        <property file="${ivy.settings.dir}/ivysettings.properties"/>
        <property name="maven-ant-tasks.install.version" value="2.1.3"/>
        <property name="maven-ant-tasks.jar.file" value="maven-ant-tasks-${maven-ant-tasks.install.version}.jar"/>

        <mkdir dir="${lib.dir}"/>
        <mkdir dir="${ivy.jar.dir}"/>

        <!-- Comment out the following lines to build the GATK without a network connection, assuming you have all of the libraries cached already -->

        <get src="http://repo1.maven.org/maven2/org/apache/ivy/ivy/${ivy.install.version}/${ivy.jar.file}"
             dest="${ivy.jar.dir}/${ivy.jar.file}"
             usetimestamp="true"/>
        <taskdef resource="org/apache/ivy/ant/antlib.xml"
                 uri="antlib:org.apache.ivy.ant"
                 classpath="${ivy.jar.dir}/${ivy.jar.file}"/>

        <get src="http://repo1.maven.org/maven2/org/apache/maven/maven-ant-tasks/${maven-ant-tasks.install.version}/${maven-ant-tasks.jar.file}"
             dest="${ivy.jar.dir}/${maven-ant-tasks.jar.file}"
             usetimestamp="true"/>
        <taskdef resource="org/apache/maven/artifact/ant/antlib.xml"
                 uri="antlib:antlib:org.apache.maven.artifact.ant"
                 classpath="${ivy.jar.dir}/${maven-ant-tasks.jar.file}"/>

        <!-- End network lines -->

        <ivy:settings file="${ivy.settings.dir}/ivysettings.xml"/>
        <property name="init.resolve.done" value="true"/>
    </target>

    <target name="resolve" depends="init.resolve,init" description="Locate and download library dependencies">
        <property name="ivy.conf" value="default"/>
        <ivy:retrieve file="ivy.xml" conf="${ivy.conf}" />
        <!-- Remove old versions of ivy jars AFTER the ivy:retrieve has been class loaded. -->
        <delete file="${ivy.jar.dir}/ivy-2.0.0.jar"/>
        <delete file="${ivy.jar.dir}/ivy-2.2.0-rc1.jar"/>
    </target>


    <!-- ******************************************************************************** -->
    <!-- Initialization                                                                   -->
    <!-- ******************************************************************************** -->

    <!-- Targets for generating the build version -->
    <target name="git.describe">
      <exec executable="git" outputproperty="git.describe.output" resultproperty="git.describe.exit.value" failonerror="false">
        <arg line="describe --long" />
      </exec>
      <condition property="git.describe.succeeded">
        <equals arg1="${git.describe.exit.value}" arg2="0" />
      </condition>
    </target>

    <target name="tagged.build.version" depends="git.describe" if="git.describe.succeeded">
        <property name="build.version" value="${git.describe.output}" />
    </target>

    <target name="git.rev-parse" depends="git.describe" unless="git.describe.succeeded">
      <exec executable="git" outputproperty="git.rev-parse.output" resultproperty="git.rev-parse.exit.value" failonerror="false">
        <arg line="rev-parse --short HEAD" />
      </exec>
      <condition property="git.rev-parse.succeeded">
        <equals arg1="${git.rev-parse.exit.value}" arg2="0" />
      </condition>
    </target>

    <target name="untagged.build.version" depends="git.rev-parse" if="git.rev-parse.succeeded">
        <property name="build.version" value="${git.rev-parse.output}" />
    </target>

    <target name="generate.build.version" depends="tagged.build.version, untagged.build.version">
        <!-- Set build.version to exported if no other value has been set -->
        <property name="build.version" value="exported" />
    </target>


    <!-- INIT OVERRIDES: call these targets BEFORE init to override build defaults -->
    <target name="init.build.publiconly">
        <property name="build.target" value="public" />
    </target>

    <target name="init.build.publicprotectedonly">
        <property name="build.target" value="protected" />
    </target>

    <target name="init.build.all">
        <property name="build.target" value="all" />
    </target>

    <target name="init.javaonly">
        <property name="compile.scala" value="false" />
    </target>

    <target name="init.javaandscala">
        <property name="compile.scala" value="true" />
    </target>

    <target name="init.usecontracts">
        <property name="use.contracts" value="true" />
    </target>


    <!-- INIT -->
    <target name="init" depends="generate.build.version">
        <tstamp>
            <format property="build.timestamp" pattern="yyyy/MM/dd HH:mm:ss"/>
        </tstamp>

        <!-- These properties should be overridden before init is called if the defaults are not desired -->
        <property name="build.target" value="${default.build.target}" />
        <property name="compile.scala" value="${compile.scala.by.default}" />
        <property name="use.contracts" value="${use.contracts.by.default}" />
        <property name="executable" value="${default.executable}" />

        <!-- Determine what should be built -->
        <condition property="include.scala">
            <equals arg1="${compile.scala}" arg2="true" />
        </condition>

        <condition property="include.private">
            <and>
                <available file="${private.dir}" />
                <equals arg1="${build.target}" arg2="all" />
            </and>
        </condition>

        <condition property="include.protected">
            <and>
                <available file="${protected.dir}" />
                <or>
                    <equals arg1="${build.target}" arg2="all" />
                    <equals arg1="${build.target}" arg2="protected" />
                </or>
            </and>
        </condition>

        <condition property="include.contracts">
            <equals arg1="${use.contracts}" arg2="true" />
        </condition>

        <condition property="include.external">
            <available file="${external.dir}"/>
        </condition>

        <!-- Construct display strings for the build properties print out -->

        <condition property="include.scala.display.string" value="yes" else="no">
            <isset property="include.scala" />
        </condition>

        <condition property="include.private.display.string" value="yes" else="no">
            <isset property="include.private" />
        </condition>

        <condition property="include.protected.display.string" value="yes" else="no">
            <isset property="include.protected" />
        </condition>

        <condition property="include.external.display.string" value="yes" else="no">
            <isset property="include.external" />
        </condition>

        <condition property="include.contracts.display.string" value="yes" else="no">
            <isset property="include.contracts" />
        </condition>

        <!-- Print out build properties -->
        <echo message="BUILD PROPERTIES" />
        <echo message="Include Scala?     : ${include.scala.display.string}" />
        <echo message="Include Private?   : ${include.private.display.string}" />
        <echo message="Include Protected? : ${include.protected.display.string}" />
        <echo message="Include External?  : ${include.external.display.string}" />
        <echo message="Include Contracts? : ${include.contracts.display.string}" />
        <echo message="Source revision    : ${build.version}" />
        <echo message="Build time         : ${build.timestamp}" />

        <!-- Create the build directory structure used by compile -->
        <mkdir dir="${build.dir}"/>
        <mkdir dir="${lib.dir}"/>
        <mkdir dir="${java.classes}"/>
        <mkdir dir="${java.contracts.dir}"/>
    </target>


    <!-- ******************************************************************************** -->
    <!-- Java Compilation                                                                 -->
    <!-- ******************************************************************************** -->

    <target name="gatk.compile.internal.source" depends="init,resolve">
        <javac fork="true" memoryMaximumSize="512m" destdir="${java.classes}" debug="true" debuglevel="lines,vars,source" classpathref="external.dependencies" tempdir="${java.io.tmpdir}">
            <src refid="java.source.path" />
            <compilerarg value="-proc:none" />
        </javac>
    </target>

    <target name="gatk.compile.external.source" depends="gatk.compile.internal.source" if="include.external">
        <subant target="compile" genericantfile="build.xml">
            <property name="build.dir" refid="external.build.dir" />
            <property name="dist.dir" refid="external.dist.dir" />
            <property name="gatk.classpath" refid="external.gatk.classpath" />
            <fileset dir="${external.dir}" includes="*/build.xml" erroronmissingdir="false" />
        </subant>
    </target>

    <target name="gatk.compile.source" depends="gatk.compile.internal.source,gatk.compile.external.source" />

    <target name="gatk.contracts" depends="gatk.compile.source" if="include.contracts">
        <javac fork="true" memoryMaximumSize="512m" destdir="${java.contracts.dir}" debug="true" debuglevel="lines,vars,source" tempdir="${java.io.tmpdir}" >
            <src refid="java.source.path" />
            <classpath>
                <path refid="external.dependencies" />
                <pathelement path="${java.classes}" />
            </classpath>
            <compilerarg value="-Acom.google.java.contract.debug"/>
            <compilerarg value="-Acom.google.java.contract.dump=${contract.dump.dir}"/>
            <compilerarg value="-proc:only"/>
        </javac>
    </target>

    <target name="gatk.compile" depends="init,resolve,gatk.compile.source,gatk.contracts" />


    <!-- ******************************************************************************** -->
    <!-- Scala Compilation                                                                -->
    <!-- ******************************************************************************** -->

    <target name="init.queue-extensions.generate" depends="gatk.compile">
        <condition property="uptodate.queue-extensions.generate">
            <or>
                <not>
                    <isset property="include.scala"/>
                </not>
                <uptodate targetfile="${queue-extensions.source.dir}">
                    <srcfiles refid="java.class.files"/>
                    <srcfiles file="${queue-extensions.gatk.jar}"/>
                </uptodate>
            </or>
        </condition>
    </target>

    <!-- NOTE: Extracting help first to avoid "Unable to load help text.  Help output will be sparse." warning message. -->
    <target name="queue-extensions.generate" depends="gatk.compile,extracthelp,init.queue-extensions.generate" unless="uptodate.queue-extensions.generate">
        <mkdir dir="${queue-extensions.source.dir}"/>
        <echo>Generating Queue GATK extensions...</echo>
        <java fork="true" failonerror="true" classname="org.broadinstitute.sting.queue.extensions.gatk.GATKExtensionsGenerator" >
            <arg value="-outDir" />
            <arg path="${queue-extensions.source.dir}" />
            <arg value="-l" />
            <arg value="WARN" />
            <classpath>
                <file file="${queue-extensions.gatk.jar}"/>
                <path refid="scala.dependencies"/>
            </classpath>
        </java>
        <touch>
            <file file="${queue-extensions.source.dir}"/>
        </touch>
    </target>

    <target name="init.scala.compile" depends="resolve">
        <path id="scala.classpath">
            <fileset dir="${lib.dir}">
                <include name="scala-compiler-*.jar"/>
                <include name="scala-library-*.jar"/>
                <include name="scala-reflect-*.jar"/>
            </fileset>
        </path>
        <taskdef resource="scala/tools/ant/antlib.xml">
            <classpath refid="scala.classpath"/>
        </taskdef>
    </target>

    <!-- Scala depends on the java compile -->
    <target name="scala.compile" depends="init,resolve,gatk.compile,queue-extensions.generate,init.scala.compile" if="include.scala">
        <mkdir dir="${scala.classes}"/>
        <echo>Building Scala...</echo>
        <scalac fork="true" jvmargs="-Xmx512m" destdir="${scala.classes}" classpathref="scala.dependencies" deprecation="yes" unchecked="yes" addparams="-feature">
            <src refid="scala.source.path" />
            <src path="${queue-extensions.source.dir}" />
            <include name="**/*.scala" />
        </scalac>
    </target>


    <!-- ******************************************************************************** -->
    <!-- Sting Resource File Generation                                                   -->
    <!-- ******************************************************************************** -->

    <target name="init.extracthelp" depends="gatk.compile">
        <loadfile property="properties.version" srcfile="${basedir}/${resource.path}" failonerror="false" quiet="true">
            <filterchain>
                <linecontains>
                    <contains value="org.broadinstitute.sting.gatk.CommandLineGATK.version"/>
                </linecontains>
                <tokenfilter>
                    <replaceregex pattern="^.*\.(.*?)$" replace="\1"/>
                </tokenfilter>
                <striplinebreaks/>
            </filterchain>
        </loadfile>

        <!-- This fileset will contain only source files modified since the resource file was last generated,
             or all source files if the resource file doesn't exist -->
        <fileset dir="${basedir}" id="modified.source.files">
            <patternset refid="java.source.files.pattern" />
            <include name="${external.dir}/**/*.java"/>
            <depend targetdir="${basedir}">
                <mapper type="merge" to="${resource.path}"/>
            </depend>
        </fileset>

        <!-- Set the sources.modified property only if our fileset of modified source files is non-empty -->
        <pathconvert refid="modified.source.files" property="sources.modified" setonempty="false"/>

        <!-- Due to a limitation in the doclet API, we always need to pass package-info files to javadoc -->
        <fileset dir="${basedir}" id="package.info.files">
            <include name="${java.public.source.dir}/**/package-info.java"/>
            <include name="${java.private.source.dir}/**/package-info.java" if="include.private" />
            <include name="${java.protected.source.dir}/**/package-info.java" if="include.protected" />
            <include name="${external.dir}/**/package-info.java"/>
        </fileset>

        <condition property="uptodate.extracthelp">
            <or>
                <isset property="disable.help"/>
                <and>
                    <not>
                        <isset property="sources.modified"/>
                    </not>
                    <equals arg1="${properties.version}" arg2="${build.version}"/>
                </and>
            </or>
        </condition>
    </target>

    <target name="extracthelp" depends="init.extracthelp" unless="uptodate.extracthelp">
        <path id="doclet.classpath">
            <path refid="external.dependencies" />
            <pathelement location="${java.classes}" />
	    <pathelement location="${clover.jar}" />
        </path>

        <javadoc doclet="org.broadinstitute.sting.utils.help.ResourceBundleExtractorDoclet"
                 docletpathref="doclet.classpath"
                 classpathref="external.dependencies"
                 classpath="${java.classes}"
		 maxmemory="2g"
                 additionalparam="-build-timestamp &quot;${build.timestamp}&quot; -absolute-version ${build.version} -out ${basedir}/${resource.path} -quiet">
            <sourcefiles>
                <union>
                    <fileset refid="modified.source.files"/>
                    <fileset refid="package.info.files"/>
                </union>
            </sourcefiles>
        </javadoc>
    </target>


    <!-- ******************************************************************************** -->
    <!-- Build Jars                                                                       -->
    <!-- ******************************************************************************** -->

    <target name="sting.compile" depends="gatk.compile, scala.compile" />

    <target name="init.jar" depends="sting.compile,extracthelp">
        <mkdir dir="${dist.dir}"/>
        <copy todir="${dist.dir}">
            <fileset dir="${lib.dir}" includes="*.jar"/>
        </copy>
    </target>

    <target name="R.public.tar">
        <mkdir dir="${R.tar.dir}/${R.package.path}" />
        <tar compression="gzip" basedir="${R.public.src.dir}/${R.package.path}" includes="gsalib/**" destfile="${R.tar.dir}/${R.package.path}/gsalib.tar.gz" />
    </target>

    <target name="R.script.stage">
        <mkdir dir="${R.script.staging.dir}" />
        <copy todir="${R.script.staging.dir}" overwrite="true">
            <fileset refid="R.script.source.files" />
            <!-- remove the initial path components (eg., public/R/scripts) when doing the copy -->
            <!-- ant 1.8.2 has a cutdirsmapper, but ant versions < 1.8.2 are too common to use it -->
            <mapper type="regexp" from="^(${R.public.scripts.dir}|${R.private.scripts.dir}|${R.protected.scripts.dir})/(.*)" to="\2" />
        </copy>
    </target>

    <target name="sting-utils.jar" depends="gatk.compile, init.jar, R.public.tar, R.script.stage">
        <jar jarfile="${dist.dir}/StingUtils.jar">
            <fileset dir="${java.classes}" includes="**/sting/utils/**/*.class"/>
            <fileset dir="${java.classes}" includes="**/sting/commandline/**/*.class"/>
            <fileset dir="${java.classes}" includes="**/sting/pipeline/**/*.class"/>
            <fileset dir="${java.classes}" includes="**/sting/tools/**/*.class"/>
            <fileset dir="${java.classes}" includes="**/sting/jna/**/*.class"/>
            <fileset dir="${java.classes}" includes="net/sf/picard/**/*.class"/>
            <fileset dir="${java.classes}" includes="net/sf/samtools/**/*.class"/>
            <fileset dir="${R.tar.dir}">
                <include name="**/${R.package.path}/**/*.tar.gz"/>
            </fileset>
            <fileset dir="${R.script.staging.dir}">
                <include name="**/sting/utils/**/*.R"/>
            </fileset>
            <manifest>
                <attribute name="Premain-Class" value="org.broadinstitute.sting.utils.instrumentation.Sizeof" />
            </manifest>
        </jar>
    </target>

    <target name="na12878kb.jar" depends="gatk.compile,init.jar">
        <jar jarfile="${dist.dir}/na12878kb.jar">
            <fileset dir="${java.classes}">
              <include name="org/broadinstitute/sting/utils/GenomeLocParser*.class"/>
              <include name="org/broadinstitute/sting/utils/GenomeLoc.class"/>
              <include name="org/broadinstitute/sting/utils/HasGenomeLocation.class"/>
              <include name="org/broadinstitute/sting/utils/BaseUtils*.class"/>
              <include name="org/broadinstitute/sting/utils/Utils.class"/>
              <include name="org/broadinstitute/sting/utils/MRUCaching*.class"/>
              <include name="org/broadinstitute/sting/utils/exceptions/**/*.class"/>
              <include name="org/broadinstitute/sting/gatk/walkers/na12878kb/core/**/*.class"/>
              <include name="net/sf/picard/reference/FastaSequenceFile.class"/>
            </fileset>
	    <fileset dir="${java.private.source.dir}">
              <include name="org/broadinstitute/sting/gatk/walkers/na12878kb/core/resources/**/*"/>
	    </fileset>
        </jar>
    </target>

    <target name="gatk.jar" depends="gatk.compile, init.jar, R.script.stage">
        <jar jarfile="${dist.dir}/GenomeAnalysisTK.jar">
            <path refid="gatk.resources"/>
            <fileset dir="${java.contracts.dir}" />
            <fileset dir="${java.classes}">
	          <include name="${resource.file}" />
              <include name="**/sting/gatk/**/*.class" />
              <include name="**/sting/alignment/**/*.class"/>
            </fileset>
            <fileset dir="${R.script.staging.dir}">
                <include name="**/sting/gatk/**/*.R"/>
                <include name="**/sting/alignment/**/*.R"/>
            </fileset>
            <fileset dir="${key.dir}">
                <include name="**/*.key"/>
            </fileset>
            <manifest>
                <attribute name="Main-Class" value="org.broadinstitute.sting.gatk.CommandLineGATK" />
            </manifest>
        </jar>

        <jar jarfile="${dist.dir}/Aligner.jar">
            <fileset dir="${java.classes}" includes="**/sting/alignment/**/*.class" />
        </jar>

        <subant target="dist" genericantfile="build.xml">
            <property name="build.dir" refid="external.build.dir" />
            <property name="dist.dir" refid="external.dist.dir" />
            <property name="gatk.classpath" refid="external.gatk.classpath" />
            <fileset dir="${external.dir}" includes="*/build.xml" erroronmissingdir="false" />
        </subant>
    </target>

    <target name="scala.jar" depends="scala.compile, init.jar" if="include.scala">
        <jar jarfile="${dist.dir}/GATKScala.jar">
          <fileset dir="${scala.classes}">
            <include name="org/broadinstitute/sting/scala/**/*.class"/>
          </fileset>
        </jar>
    </target>

    <target name="queue.jar" depends="scala.compile, init.jar, R.script.stage" if="include.scala">
        <jar jarfile="${dist.dir}/Queue.jar">
            <fileset dir="${scala.classes}">
                <include name="org/broadinstitute/sting/queue/**/*.class"/>
            </fileset>
            <fileset dir="${java.classes}">
              <include name="org/broadinstitute/sting/queue/**/*.class" />
            </fileset>
            <fileset dir="${R.script.staging.dir}">
                <include name="org/broadinstitute/sting/queue/**/*.R"/>
            </fileset>
            <manifest>
                <attribute name="Main-Class" value="org.broadinstitute.sting.queue.QCommandLine" />
            </manifest>
        </jar>
    </target>

    <target name="sting.jar" depends="sting-utils.jar, gatk.jar, queue.jar" />

    <target name="init.manifests" depends="sting.jar">
        <pathconvert property="jar.classpath" pathsep=" ">
            <flattenmapper/>
            <fileset dir="${dist.dir}" includes="*.jar"/>
            <filelist files="GATKScala.jar"/>
        </pathconvert>
    </target>

    <target name="sting-utils.manifests" depends="sting-utils.jar, init.manifests">
        <jar jarfile="${dist.dir}/StingUtils.jar" update="true">
            <manifest>
                <attribute name="Class-Path" value="${jar.classpath}"/>
            </manifest>
        </jar>
    </target>

    <target name="gatk.manifests" depends="gatk.jar, init.manifests">
        <jar jarfile="${dist.dir}/GenomeAnalysisTK.jar" update="true">
            <manifest>
                <attribute name="Class-Path" value="${jar.classpath}"/>
            </manifest>
        </jar>
    </target>

    <target name="queue.manifests" depends="queue.jar, init.manifests" if="include.scala">
        <jar jarfile="${dist.dir}/Queue.jar" update="true" >
            <manifest>
                <attribute name="Class-Path" value="${jar.classpath}" />
            </manifest>
        </jar>
    </target>

    <target name="sting.manifests" depends="sting-utils.manifests, gatk.manifests, queue.manifests" />


    <!-- ******************************************************************************** -->
    <!-- Top-Level Build Targets                                                          -->
    <!-- ******************************************************************************** -->

    <target name="dist" depends="sting.manifests" description="Build the GATK and Queue" />

    <target name="gatk" depends="init.javaonly, sting.manifests" description="Build the GATK only" />

    <target name="queue" depends="dist" />  <!-- Obsolete target. Now just an alias for dist -->

    <target name="scala" depends="scala.jar" />


    <!-- ******************************************************************************** -->
    <!-- GATKDocs                                                                          -->
    <!-- ******************************************************************************** -->

    <target name="gatkdocs" depends="gatk.compile" description="Generate GATK HTML documentation">
        <path id="doclet.classpath">
            <path refid="external.dependencies" />
            <pathelement location="${java.classes}" />
        </path>

        <!-- Run with -Dgatkdocs.include.hidden=true to include documentation for hidden features -->
        <condition property="gatkdocs.include.hidden.arg" value="-include-hidden" else="">
            <isset property="gatkdocs.include.hidden" />
        </condition>

        <javadoc doclet="org.broadinstitute.sting.utils.help.GATKDoclet"
                 docletpathref="doclet.classpath"
                 classpathref="external.dependencies"
                 classpath="${java.classes}"
		 maxmemory="2g"
                 additionalparam="${gatkdocs.include.hidden.arg} -private -build-timestamp &quot;${build.timestamp}&quot; -absolute-version ${build.version} -quiet"> <!-- -test to only do DocumentationTest walker -->
            <sourcefiles>
                <fileset refid="java.source.files"/>
            </sourcefiles>
        </javadoc>
    </target>


    <!-- ******************************************************************************** -->
    <!-- Javadoc                                                                          -->
    <!-- ******************************************************************************** -->

    <target name="init.javadoc">
        <mkdir dir="${javadoc.dir}" />
    </target>

    <target name="javadoc" depends="init.javadoc,resolve" description="Generate Javadoc">
        <javadoc destdir="${javadoc.dir}" classpathref="external.dependencies">
            <fileset refid="java.source.files" />
            <sourcepath path="${external.dir}" />
        </javadoc>
    </target>


    <!-- ******************************************************************************** -->
    <!-- Scaladoc                                                                         -->
    <!-- ******************************************************************************** -->

    <target name="init.scaladoc">
        <mkdir dir="${scaladoc.dir}" />
    </target>

    <!-- NOTE: the scaladoc target requires that the environment variable ANT_OPTS has been set to "-Xmx1G" -->

    <target name="scaladoc" depends="resolve,queue-extensions.generate,init.scala.compile,scala.compile,init.scaladoc" description="Generate Scaladoc">
        <scaladoc srcdir="${basedir}" destdir="${scaladoc.dir}" classpathref="scala.dependencies" deprecation="yes" unchecked="yes">
            <patternset refid="scala.source.files.pattern" />
            <include name="${queue-extensions.source.dir}/**/*.scala" />
        </scaladoc>
    </target>


    <!-- ******************************************************************************** -->
    <!-- Release-related tasks                                                            -->
    <!-- ******************************************************************************** -->

    <target name="init.executable.gatkfull" depends="init.build.publicprotectedonly, init.javaonly">
        <property name="executable" value="GenomeAnalysisTK" />
    </target>

    <target name="init.executable.gatkall" depends="init.build.all, init.javaonly">
        <property name="executable" value="GenomeAnalysisTK" />
    </target>

    <target name="init.executable.queuefull" depends="init.build.publicprotectedonly, init.javaandscala">
        <property name="executable" value="Queue" />
    </target>

    <target name="init.executable.queueall" depends="init.build.all, init.javaandscala">
        <property name="executable" value="Queue" />
    </target>

    <target name="require.executable">
        <condition property="no.executable.defined">
            <or>
                <equals arg1="${executable}" arg2="none" />
                <equals arg1="${executable}" arg2="$${executable}" />
            </or>
        </condition>
        <fail message="No executable defined. Call a more specific packaging/release target, or define an executable manually" if="no.executable.defined" />
    </target>

    <target name="require.bcel">
        <fileset id="bcel.jar" dir="${user.home}/.ant/lib">
            <include name="bcel-*.jar" />
        </fileset>
        <pathconvert refid="bcel.jar" property="bcel.jar.installed" setonempty="false" />

        <fileset id="ant.bcel.jar" dir="${user.home}/.ant/lib">
            <include name="ant-apache-bcel-*.jar" />
        </fileset>
        <pathconvert refid="ant.bcel.jar" property="ant.bcel.jar.installed" setonempty="false" />

        <condition property="bcel.installed">
            <and>
                <isset property="bcel.jar.installed" />
                <isset property="ant.bcel.jar.installed" />
            </and>
        </condition>
        <fail unless="bcel.installed"
              message="Required bcel libraries for GATK packaging not installed in ${user.home}/.ant/lib/${line.separator}The bcel jar can be found in the lib directory of a GATK clone after compiling, and the ant-apache-bcel jar can be downloaded from here: http://repo1.maven.org/maven2/ant/ant-apache-bcel/1.6.5/ant-apache-bcel-1.6.5.jar${line.separator}Please copy these two jar files to ${user.home}/.ant/lib/" />
    </target>

    <!-- Unzip all classes from their current locations and assemble them in a staging directory -->
    <target name="stage">
        <mkdir dir="${staging.dir}"/>
        <!--
            HACK: Create the edu directory before EDU on case-insensitive mac filesystems.
            The ivy dependency colt -> concurrent contains an EDU.oswego package which
            BCEL doesn't even pull in but messes up edu.mit.broad.
          -->
        <mkdir dir="${staging.dir}/edu"/>
        <unjar dest="${staging.dir}" overwrite="false">
          <fileset dir="${dist.dir}">
            <patternset refid="dependency.mask" />
          </fileset>
        </unjar>

        <!-- HACK: The GATK jar itself contains overrides for some core classes.  Make sure the GATK.jar is unrolled last. -->
        <unjar dest="${staging.dir}" overwrite="true">
          <fileset dir="${dist.dir}" includes="**/GenomeAnalysisTK.jar"/>
        </unjar>
    </target>


    <!-- Build a package consisting of all supporting files. Don't call this target directly. Call one of the specific packaging targets below -->
    <target name="package" depends="require.clean,require.bcel,dist,stage,require.executable">
      <mkdir dir="${package.output.dir}" />
      <xslt destdir="${package.output.dir}" style="${package.xml.dir}/CreatePackager.xsl" useImplicitFileset="false">
          <flattenmapper/>
          <fileset dir="${package.xml.dir}">
              <include name="${executable}.xml" />
          </fileset>
          <fileset dir="${external.dir}" erroronmissingdir="false">
              <include name="*/${executable}.xml" />
          </fileset>
      </xslt>
      <ant antfile="${package.output.dir}/${executable}.xml" target="package" />
    </target>

    <!-- Package specific versions of the GATK/Queue. ALWAYS do an ant clean before invoking these! -->

    <!-- GATK "full" == public + protected, ie., the standard binary release of the GATK  -->
    <target name="package.gatk.full" depends="init.executable.gatkfull,package" description="Create a standalone GATK jar with public and protected code" />

    <!-- GATK "all" == public + protected + private. Should never be publicly released -->
    <target name="package.gatk.all" depends="init.executable.gatkall,package" description="Create a standalone GATK jar with public, protected, and private code" />

    <target name="package.queue.full" depends="init.executable.queuefull,package" description="Create a standalone Queue jar with public and protected code" />

    <target name="package.queue.all" depends="init.executable.queueall,package" description="Create a standalone Queue jar with public, protected, and private code" />

    <!-- Release a build. Don't call this target directly. Call one of the specific release targets below -->
    <target name="release" depends="require.executable">
        <ant antfile="${package.output.dir}/${executable}.xml" target="release" />
    </target>

    <!-- Release specific versions of the GATK/Queue. ALWAYS do an ant clean before invoking these! -->
    <target name="release.gatk.full" depends="package.gatk.full,release" />

    <target name="release.queue.full" depends="package.queue.full,release" />

    <!-- Build a subset of picard with only those classes we need by completely abusing the packaging system -->
    <!-- TODO: Reuse as much as possible of the 'stage' and 'package' targets -->
    <target name="build-picard-private" depends="resolve">
      <!-- Build out a classpath -->
      <pathconvert property="required.picard.jars" pathsep=":">
        <fileset dir="${basedir}">
	     <include name="${staging.dir}" />
	     <include name="${lib.dir}/picard-*.*.*.jar" />
	     <include name="${lib.dir}/sam-*.jar" />
	   </fileset>
      </pathconvert>
      <echo message="required.picard.jars=${required.picard.jars}" />

      <!-- Stage picard-private -->
      <delete dir="${staging.dir}" />
      <mkdir dir="${staging.dir}" />
      <unjar src="${picard.dist.dir}/picard-private.jar" dest="${staging.dir}" overwrite="true" />

      <!-- Use the packaging system to extract parts of picard-private we need -->
      <mkdir dir="${package.output.dir}" />
      <xslt in="${package.xml.dir}/PicardPrivate.xml" out="${package.output.dir}/BuildPicardPrivate.xml" style="${package.xml.dir}/CreatePackager.xsl" />
      <ant antfile="${package.output.dir}/BuildPicardPrivate.xml">
	    <property name="additional.jars" value="${required.picard.jars}" />
      </ant>
    </target>

    <!-- Maven install a package consisting of all supporting files. Don't call this target directly. Call one of the specific packaging targets below -->
    <target name="mvninstall" depends="package">
        <property name="mvn.build.version" value="0.0.2" />
        <!--
        We should use the build version or better yet a git tag version, but tags are currently missing. Alternatively how do we then depend on the LATEST?
        <property name="mvn.build.version" value="${build.version}" />
        -->
        <artifact:pom id="${executable}.pom" groupId="org.broadinstitute.sting" artifactId="${executable}" version="${mvn.build.version}" name="${executable}" />
        <artifact:writepom pomRefId="${executable}.pom" file="${package.output.dir}/${executable}-${build.version}/${executable}.pom.xml"/>
        <artifact:install file="${package.output.dir}/${executable}-${build.version}/${executable}.jar">
            <artifact:pom file="${package.output.dir}/${executable}-${build.version}/${executable}.pom.xml" />
        </artifact:install>
    </target>

    <!-- Maven install specific versions of the GATK/Queue. ALWAYS do an ant clean before invoking these! -->
    <target name="mvninstall.gatk.full" depends="package.gatk.full,mvninstall" />

    <target name="mvninstall.queue.all" depends="package.queue.all,mvninstall" />

    <target name="mvninstall.queue.full" depends="package.queue.full,mvninstall" />

    <!-- ******************************************************************************** -->
    <!-- Clean                                                                            -->
    <!-- ******************************************************************************** -->

    <target name="clean.gatkdocs">
        <delete dir="${gatkdocs.dir}"/>
    </target>

    <target name="clean.javadoc">
        <delete dir="${javadoc.dir}" />
    </target>

    <target name="clean.scaladoc">
        <delete dir="${scaladoc.dir}" />
    </target>

    <target name="-check.clover">
      <available property="clover.installed" classname="com.cenqua.clover.CloverInstr" />
    </target>

    <target name="clean.clover" depends="-check.clover" if="clover.installed">
      <clover-clean/>
    </target>

    <target name="clean.gsalib">
        <!-- Currently not cleaning out the lib during 'ant clean' -->
      <exec executable="R" failonerror="false">
        <arg line="R CMD REMOVE gsalib" />
      </exec>
    </target>

    <target name="clean" description="Clean up old build-related directories" depends="clean.javadoc,clean.scaladoc,clean.gatkdocs,clean.clover">
        <delete dir="${build.dir}"/>
        <delete dir="${lib.dir}"/>
        <delete dir="${contract.dump.dir}"/>
        <delete dir="${staging.dir}"/>
        <delete dir="${dist.dir}"/>
        <delete dir="${pipelinetest.dir}"/>
        <delete dir="${integration.tests.dir}"/>
    </target>

    <!-- Depend on this target if your target requires a clean working directory but you don't want to depend on clean directly -->
    <target name="require.clean">
        <condition property="not.clean">
            <or>
                <available file="${build.dir}" />
                <available file="${lib.dir}" />
                <available file="${contract.dump.dir}" />
                <available file="${staging.dir}" />
                <available file="${dist.dir}" />
                <available file="${pipelinetest.dir}" />
                <available file="${integration.tests.dir}" />
                <available file="${javadoc.dir}" />
                <available file="${scaladoc.dir}" />
                <available file="${gatkdocs.dir}" />
            </or>
        </condition>
        <fail message="Selected build target requires a clean working directory. Run ant clean and then try again." if="not.clean" />
    </target>


    <!-- ******************************************************************************** -->
    <!-- gsalib                                                                           -->
    <!-- ******************************************************************************** -->

    <!-- Build gsalib R module -->
    <target name="gsalib" description="Build the gsalib R module">
      <exec executable="R" failonerror="true">
        <arg line="R CMD INSTALL --preclean ${R.public.src.dir}/${R.package.path}/gsalib" />
      </exec>
    </target>


    <!-- ***************************************************************************** -->
    <!-- ***********               Tests and associated tasks                ********* -->
    <!-- ***************************************************************************** -->

    <!-- Properties and Paths -->

    <property name="java.test.classes" value="${build.dir}/java/testclasses"/>
    <property name="java.public.test.sources" value="${public.dir}/java/test"/>
    <property name="java.private.test.sources" value="${private.dir}/java/test"/>
    <property name="java.protected.test.sources" value="${protected.dir}/java/test"/>
    <property name="scala.test.classes" value="${build.dir}/scala/testclasses"/>
    <property name="scala.public.test.sources" value="${public.dir}/scala/test"/>
    <property name="scala.private.test.sources" value="${private.dir}/scala/test"/>
    <property name="scala.protected.test.sources" value="${protected.dir}/scala/test"/>
    <property name="integration.tests.dir" value="integrationtests" />
    <property name="pipelinetest.dir" value="pipelinetests" />
    <property name="report" value="${build.dir}/report"/>
    <property name="iwww.report.dir" value="${user.home}/private_html/report"/>
    <property name="test.output" value="${dist.dir}/test"/>
    <property name="testng.jar" value="${lib.dir}/testng-6.8.jar"/>

    <path id="java.test.source.path">
        <dirset dir="${basedir}">
            <include name="${java.public.test.sources}" />
            <include name="${java.private.test.sources}" if="include.private" />
            <include name="${java.protected.test.sources}" if="include.protected" />
        </dirset>
    </path>

    <path id="scala.test.source.path">
        <dirset dir="${basedir}">
            <include name="${scala.public.test.sources}" />
            <include name="${scala.private.test.sources}" if="include.private" />
            <include name="${scala.protected.test.sources}" if="include.protected" />
        </dirset>
    </path>

    <path id="testng.dependencies">
        <fileset dir="${lib.dir}">
            <include name="jcommander*.jar"/>
            <include name="guice*.jar"/>
            <include name="junit*.jar"/>
            <include name="bsh*.jar"/>
            <include name="snakeyaml*.jar"/>
            <include name="reportng*.jar"/>
        </fileset>
    </path>

    <path id="testng.default.classpath">
        <path refid="build.results" />
        <pathelement path="${clover.jar}"/>
        <pathelement location="${java.contracts.dir}" />
        <pathelement location="${java.test.classes}" />
        <pathelement location="${scala.test.classes}" />
    </path>

    <!-- Test targets -->

    <target name="clover.report">
      <clover-report coverageCacheSize="nocache">
      <current outfile="clover_html" title="GATK clover report" showUniqueCoverage="false" numThreads="4">
	  <format type="html" filter="catch,static,property"/>
	  <fileset dir="public">
	    <patternset id="clover.excludes">
	      <exclude name="**/*UnitTest.java"/>
	      <exclude name="**/*TestProvider*.java"/>
	      <exclude name="**/*PerformanceTest.java"/>
	      <exclude name="**/*Benchmark.java"/>
	      <exclude name="**/*LargeScaleTest.java"/>
	      <exclude name="**/*IntegrationTest.java"/>
	      <exclude name="**/jna/**/*.java"/>
	      <exclude name="**/queue/extensions/**/*.java"/>
	      <exclude name="**/sting/utils/help/*.java"/>
	      <exclude name="**/sting/tools/*.java"/>
	      <exclude name="**/datasources/reads/utilities/*.java"/>
	      <exclude name="**/sting/alignment/**/*.java"/>
	      <exclude name="**/examples/**/*.java"/>
	    </patternset>
	  </fileset>
	  <fileset dir="private">
	    <patternset refid="clover.excludes" />
	  </fileset>
	  <fileset dir="protected">
	    <patternset refid="clover.excludes" />
	  </fileset>
	</current>
      </clover-report>
    </target>

    <target name="with.clover">
      <clover-setup fullyQualifyJavaLang="true" instrumentationLevel="${clover.instrument.level}">
      </clover-setup>
      <property name="compile.scala" value="false" /> <!-- currently doesn't work with scala -->
      <property name="test.maxmemory" value="32g"/>  <!-- clover requires lots of memory -->
      <echo message="Clover instrument level: ${clover.instrument.level}" />
    </target>

    <target name="test.init.compile">
        <mkdir dir="${java.test.classes}"/>
        <mkdir dir="${scala.test.classes}"/>
    </target>

   <target name="test.java.internal.compile" depends="dist,test.init.compile">
        <echo message="Sting: Compiling java test cases!"/>
        <javac fork="true" memoryMaximumSize="512m" destdir="${java.test.classes}" debug="true" optimize="on" tempdir="${java.io.tmpdir}">
            <src refid="java.test.source.path" />
            <classpath>
                <path refid="build.results" />
                <pathelement location="${java.contracts.dir}"/>
            </classpath>
            <compilerarg value="-proc:none"/>
        </javac>
    </target>

    <target name="test.java.external.compile" depends="dist,test.init.compile,test.java.internal.compile" if="include.external">
        <echo message="Sting: Compiling external java test cases!"/>
        <javac fork="true" memoryMaximumSize="512m" destdir="${java.test.classes}" debug="true" optimize="on" tempdir="${java.io.tmpdir}" srcdir="${external.dir}">
            <include name="*/test/**/*.java"/>
            <classpath>
                <path refid="build.results" />
                <pathelement location="${java.test.classes}"/>
                <pathelement location="${java.contracts.dir}"/>
            </classpath>
            <compilerarg value="-proc:none"/>
        </javac>
    </target>

    <target name="test.java.compile" depends="test.java.internal.compile, test.java.external.compile"/>

    <target name="test.scala.compile" depends="test.java.compile,scala.compile" if="include.scala">
        <echo message="Scala: Compiling test cases!"/>
        <scalac fork="true" jvmargs="-Xmx512m" destdir="${scala.test.classes}" deprecation="yes" unchecked="yes" addparams="-feature">
	        <src refid="scala.test.source.path" />
            <classpath>
                <path refid="build.results"/>
                <pathelement location="${java.test.classes}"/>
            </classpath>
        </scalac>
    </target>

    <!-- NOTE: contracts disabled for all tests now, since contracts don't work with Java 7 -->
    <target name="test.compile" depends="dist,test.java.compile,test.scala.compile" />


    <!-- Run test macro -->
    <macrodef name="run-test">
        <attribute name="testtype"/>
        <attribute name="outputdir"/>
        <attribute name="runfailed"/>

        <sequential>
            <condition property="run.failed.tests">
                <equals arg1="@{runfailed}" arg2="true"/>
            </condition>

            <!-- Get the pipeline run type.  Default to dry.  -->
            <condition property="pipeline.run" value="dry" else="${pipeline.run}">
                <equals arg1="${pipeline.run}" arg2="$${pipeline.run}" />
            </condition>

            <condition property="cofoja.jvm.args" value="-javaagent:${cofoja.jar} -Dcom.google.java.contract.log.contract=false" else="">
                <isset property="include.contracts" />
            </condition>

            <condition property="debug.jvm.args" value="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=${test.debug.port}" else="">
                <isset property="test.debug" />
            </condition>

            <mkdir dir="@{outputdir}"/>

            <echo message="" />
            <echo message="Test Classpath ID: ${testng.classpath}" />
            <property name="test.classpath.display.string" refid="${testng.classpath}" />
            <echo message="Test Classpath: ${test.classpath.display.string}" />
            <echo message="" />
            <echo message="Sting: Running @{testtype} test cases!"/>
            <echo message="Test Memory : ${test.maxmemory}" />

	    <!-- no test is allowed to run for more than 10 hours -->
            <taskdef resource="testngtasks" classpath="${testng.jar}"/>
            <testng outputDir="@{outputdir}"
                    classpathref="${testng.classpath}"
                    haltOnFailure="false" failureProperty="test.failure"
                    verbose="2"
		            timeout="36000000"
                    workingDir="${basedir}"
                    useDefaultListeners="false"
                    listeners="org.testng.reporters.FailedReporter,org.testng.reporters.JUnitXMLReporter,org.broadinstitute.sting.TestNGTestTransformer,org.broadinstitute.sting.StingTextReporter,org.uncommons.reportng.HTMLReporter">
                <jvmarg value="-Xmx${test.maxmemory}" />
                <jvmarg value="-ea" />
                <jvmarg value="-Dclover.pertest.coverage=diff" />
                <jvmarg value="-Djava.awt.headless=true" />
                <jvmarg value="-Dpipeline.run=${pipeline.run}" />
                <jvmarg value="-Djava.io.tmpdir=${java.io.tmpdir}" />
                <jvmarg line="${cofoja.jvm.args}"/>
                <jvmarg line="${debug.jvm.args}"/>

                <!-- NOTE: To run tests with debugging, use -Dtest.debug=true -Dtest.debug.port=XXXX on the command line -->

                <classfileset dir="${java.test.classes}" includes="**/@{testtype}.class"/>
                <classfileset dir="${java.external.test.classes}" erroronmissingdir="false">
                    <include name="**/@{testtype}.class" if="include.external"/>
                </classfileset>
                <classfileset dir="${scala.test.classes}" erroronmissingdir="false">
                    <include name="**/@{testtype}*.class" if="include.scala"/>
                </classfileset>

                <xmlfileset dir="${basedir}">
                    <include name="@{testtype}" if="run.failed.tests"/>
                </xmlfileset>
            </testng>

            <!-- generate a report for Bamboo or Hudson to read in -->
            <junitreport todir="@{outputdir}">
                <fileset dir="@{outputdir}">
                    <include name="*/*.xml"/>
                </fileset>
                <report format="noframes" todir="@{outputdir}"/>
            </junitreport>

	    <!-- copy the report to our private_html directory for easy viewing in a broswer -->
            <mkdir dir="${iwww.report.dir}/@{testtype}"/>
            <copy todir="${iwww.report.dir}/@{testtype}" verbose="false">
              <fileset dir="@{outputdir}"/>
            </copy>

            <fail message="test failed" if="test.failure" />
        </sequential>
    </macrodef>


    <target name="test.init">
        <property name="testng.classpath" value="testng.default.classpath" />
        <property name="test.maxmemory" value="${test.default.maxmemory}"/>
    </target>

    <target name="init.testgatkjar">
        <path id="gatk.binary.release.tests.classpath">
            <path refid="testng.dependencies" />
            <path>
                <fileset dir="${package.output.dir}">
                    <include name="**/${executable}.jar" />
                </fileset>
            </path>
            <pathelement location="${java.contracts.dir}" />
            <pathelement location="${java.test.classes}" />
            <pathelement location="${scala.test.classes}" />
            <pathelement location="${scala.classes}" />
            <path>
                <fileset dir="${lib.dir}">
                    <include name="scala*.jar"/>
                    <include name="jna*.jar"/>
                    <include name="cofoja*.jar"/>
                </fileset>
            </path>
        </path>
        <property name="testng.classpath" value="gatk.binary.release.tests.classpath" />
    </target>

    <target name="init.testqueuejar">
        <path id="queue.binary.release.tests.classpath">
            <path refid="testng.dependencies" />
            <path>
                <fileset dir="${package.output.dir}">
                    <include name="**/${executable}.jar" />
                </fileset>
            </path>
            <pathelement location="${java.contracts.dir}" />
            <pathelement location="${java.test.classes}" />
            <pathelement location="${scala.test.classes}" />
            <path>
                <fileset dir="${lib.dir}">
                    <include name="cofoja*.jar"/>
                </fileset>
            </path>
        </path>
        <property name="testng.classpath" value="queue.binary.release.tests.classpath" />
    </target>


    <target name="committests" depends="unittest,integrationtest,pipelinetest" description="Run unit tests, integration tests, and do a dry-run of the pipeline tests" />

    <!-- Order of the dependencies is significant in the *.release.tests targets -->
    <target name="gatkfull.binary.release.tests" depends="package.gatk.full,init.testgatkjar,unittest,integrationtest" />

    <target name="queuefull.binary.release.tests" depends="package.queue.full,init.testqueuejar,pipelinetest" />

    <!-- Our four different test types: UnitTest, IntegrationTest, LargeScaleTest, PipelineTest -->
    <target name="unittest" depends="test.compile,test.init" description="Run unit tests">
        <condition property="ttype" value="*UnitTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${ttype}" outputdir="${report}/${ttype}" runfailed="false"/>
    </target>

    <!-- Keep the alias "test" for "unittest" for backwards compatibility -->
    <target name="test" depends="unittest" />

    <target name="integrationtest" depends="test.compile,test.init" description="Run integration tests">
        <condition property="itype" value="*IntegrationTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${itype}" outputdir="${report}/${itype}" runfailed="false"/>
    </target>

    <target name="largescaletest" depends="test.compile,test.init" description="Run large-scale tests">
       <condition property="ptype" value="*LargeScaleTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${ptype}" outputdir="${report}/${ptype}" runfailed="false"/>
    </target>

    <target name="pipelinetest" depends="test.compile,test.init" description="Dry-run pipeline tests">
        <condition property="pipetype" value="*PipelineTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${pipetype}" outputdir="${report}/${pipetype}" runfailed="false"/>
    </target>

    <target name="pipelinetestrun" depends="test.compile,test.init" description="Run pipeline tests">
        <property name="pipeline.run" value="run"/>
        <condition property="pipetype" value="*PipelineTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${pipetype}" outputdir="${report}/${pipetype}" runfailed="false"/>
    </target>

    <target name="knowledgebasetest" depends="test.compile,test.init" description="Run knowledge base tests">
        <condition property="ktype" value="*KnowledgeBaseTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${ktype}" outputdir="${report}/${ktype}" runfailed="false"/>
    </target>

    <target name="failed-unit" depends="test.compile,test.init">
        <run-test testtype="${report}/*UnitTest/testng-failed.xml" outputdir="${report}/failed_rerun" runfailed="true"/>
    </target>

    <target name="failed-integration" depends="test.compile,test.init">
        <run-test testtype="${report}/*IntegrationTest/testng-failed.xml" outputdir="${report}/failed_rerun" runfailed="true"/>
    </target>

    <target name="failed-largescale" depends="test.compile,test.init">
        <run-test testtype="${report}/*LargeScaleTest/testng-failed.xml" outputdir="${report}/failed_rerun" runfailed="true"/>
    </target>

    <target name="failed-pipeline" depends="test.compile,test.init">
        <run-test testtype="${report}/*PipelineTest/testng-failed.xml" outputdir="${report}/failed_rerun" runfailed="true"/>
    </target>


    <!-- Fast test target that cuts major corners for speed. Requires that a full build has been done first. Java-only, single test class only -->
    <!-- Usage: ant fasttest -Dsingle=TestClass -->
    <target name="fasttest" depends="init.javaonly,init" description="Quickly run a single test">
	<property name="test.maxmemory" value="${test.default.maxmemory}"/>
        <condition property="not.clean">
            <and>
                <available file="${build.dir}" />
                <available file="${lib.dir}" />
                <available file="${dist.dir}" />
                <available file="${java.test.classes}" />
            </and>
        </condition>
        <fail message="fasttest requires a NON-CLEAN working directory (INCLUDING test classes). Do a full test build using ant test.compile first." unless="not.clean" />

        <condition property="no.single.test.specified">
            <equals arg1="${single}" arg2="$${single}" />
        </condition>
        <fail message="Must specify a specific test. Usage: ant fasttest -Dsingle=TestClass" if="no.single.test.specified" />

        <javac fork="true" memoryMaximumSize="512m" destdir="${java.classes}" debug="true" debuglevel="lines,vars,source" classpathref="external.dependencies" tempdir="${java.io.tmpdir}">
            <src refid="java.source.path" />
            <compilerarg value="-proc:none" />
        </javac>

        <javac fork="true" memoryMaximumSize="512m" destdir="${java.test.classes}" debug="true" optimize="on" tempdir="${java.io.tmpdir}">
            <src refid="java.test.source.path" />
            <classpath>
                <pathelement location="${java.classes}"/>
                <path refid="external.dependencies" />
            </classpath>
            <compilerarg value="-proc:none"/>
        </javac>

        <!-- fasttest uses the unpackaged class files in its test classpath to avoid having to rebuild the jars in dist/ -->
        <path id="testng.fasttest.classpath">
            <pathelement location="${java.classes}" />
            <pathelement location="${scala.classes}" />
            <pathelement location="${java.contracts.dir}" />
            <pathelement location="${java.test.classes}" />
            <pathelement location="${scala.test.classes}" />
            <pathelement location="${R.tar.dir}" />
            <path refid="R.script.source.path" />
            <pathelement location="${key.dir}" />
            <path refid="external.dependencies" />
            <path refid="java.source.path" />  <!-- Terrible hack to allow fasttest to see resource files stored in the source tree -->
        </path>
        <property name="testng.classpath" value="testng.fasttest.classpath" />

        <run-test testtype="${single}" outputdir="${report}/${single}" runfailed="false"/>
    </target>

    <!-- A target that runs a test without doing ANY compilation or any extra work at all -->
    <!-- Intended to enable parallel tests that share the same working directory and build -->
    <target name="runtestonly">
        <condition property="not.clean">
            <and>
                <available file="${build.dir}" />
                <available file="${lib.dir}" />
                <available file="${dist.dir}" />
                <available file="${java.test.classes}" />
            </and>
        </condition>
        <fail message="runtestonly target requires a NON-CLEAN working directory (INCLUDING test classes). Do a full test build using ant test.compile first." unless="not.clean" />

        <condition property="no.single.test.specified">
            <equals arg1="${single}" arg2="$${single}" />
        </condition>
        <fail message="Must specify a specific test. Usage: ant runtestonly -Dsingle=TestClass" if="no.single.test.specified" />

        <property name="testng.classpath" value="testng.default.classpath" />
        <property name="test.maxmemory" value="${test.default.maxmemory}"/>
        <property name="include.scala" value="true" />

        <run-test testtype="${single}" outputdir="${report}/${single}" runfailed="false"/>
    </target>

</project>
